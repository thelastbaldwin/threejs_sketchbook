<!DOCTYPE html>
<html>
<head>
	<title>Noise Terrain</title>
	<script src="js/third_party/three.min.js"></script>
	<script src="js/third_party/EffectComposer.js"></script>
	<script src="js/third_party/CopyShader.js"></script>
	<script src="js/third_party/ShaderPass.js"></script>
	<script src="js/third_party/MaskPass.js"></script>
	<script src="js/third_party/RenderPass.js"></script>
	<script src="js/third_party/stats.min.js"></script>
	<script src="js/third_party/dat.gui.min.js"></script>
	<script src="js/third_party/OrbitControls.js"></script>
	<script src="js/third_party/perlin.js"></script>
	<link rel="stylesheet" href="css/style.css">
</head>
<body>
	<div id="Stats-output"></div>
	<div id="WebGL-output"></div>
	<script>
		//use perlin noise to mess with a mesh
		var gui = new dat.GUI();
		var spotlightOptions = new function(){
			this.z = 500;
			this.height = 250;
			this.intensity = 1.0;
			this.distance = 0;
			this.angle = Math.PI/3;
			this.exponent = 10.0;
		};
		gui.add(spotlightOptions, 'z', 100, 500);
		gui.add(spotlightOptions, 'height', -200, 300);
		gui.add(spotlightOptions, 'intensity', 0.0, 1.0);
		gui.add(spotlightOptions, 'distance', 0, 1000);
		gui.add(spotlightOptions, 'angle', Math.PI/3, Math.PI/2);

		//background stuff
		var bgScene = new THREE.Scene();
		var bgCamera = new THREE.OrthographicCamera( -window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, 1, 1000 );
		bgCamera.position.z = 100;
		var bgMaterial = new THREE.ShaderMaterial({
 				uniforms: {
 					windowHeight: {
 						type: 'f',
 						value: window.innerHeight
 					},
 					mousePoint: {
 						type: 'f',
 						value: window.innerHeight/2.0
 					},
 					starsTexture: {
 						type: 't',
 						value: THREE.ImageUtils.loadTexture( 'img/stars.png')
 					},
 					amount: {
 						type: "f",
 						value: 1.0
 					}
 				},
 				depthTest: false,
 				vertexShader: [
 					'varying vec2 vUv;',
					'void main() {',
						'vUv = uv;',
			  			'gl_Position = projectionMatrix *',
			            'modelViewMatrix *',
			            'vec4(position,1.0);',
					'}'
				].join('\n'),
 				fragmentShader: [
 					'uniform float windowHeight, mousePoint, amount;',
 					'uniform sampler2D starsTexture;',
 					'varying vec2 vUv;',
					'void main() {',
						'vec3 backgroundColor = texture2D(starsTexture, vUv).rgb;',
						'gl_FragColor = vec4(mix(vec3(0.45, 0.78, 1.0), backgroundColor, clamp(gl_FragCoord.y/mousePoint, 0.0, 1.0)), 1.0);',
					'}'
				].join('\n')
 			});
		var bgPlane = new THREE.Mesh(
			new THREE.PlaneBufferGeometry(window.innerWidth * 2, window.innerHeight * 2),
			bgMaterial
		);
		bgScene.add(bgPlane);

		//main terrain stuff
		var scene = new THREE.Scene(),
			renderer = new THREE.WebGLRenderer(),
			clock = new THREE.Clock(),
			camera = new THREE.PerspectiveCamera(45, window.innerWidth/ window.innerHeight, 0.1, 1000);
		camera.position.z = -500;
		camera.position.y = 50;
		camera.lookAt(scene.position);
		// var orbitControls = new THREE.OrbitControls(camera);

		var planeGeometry = new THREE.PlaneGeometry(2000, 1000, 100, 50);
		var planePhongMaterial = new THREE.MeshPhongMaterial({ 
			color: 0xD324FF, 
			specular: 0x0000ff, 
			shininess: 100, 
			shading: THREE.FlatShading
		});

		var plane = new THREE.Mesh(planeGeometry, planePhongMaterial);
		plane.rotation.x = -Math.PI/2;

		scene.add(plane);

		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMapEnabled = true;

		var outputElement = document.getElementById('WebGL-output');
		outputElement.appendChild(renderer.domElement);

		var spotLightColor = 0xFFFEF0;
		var spotlight = new THREE.SpotLight(spotLightColor);
		spotlight.position.set(0, 100, -200);
		spotlight.castShadow = true;
		scene.add(spotlight);

		var sunMaterial = new THREE.MeshBasicMaterial({
			color: spotLightColor
		});
		var sunGeometry= new THREE.CircleGeometry(50, 32);
		var sunCircle = new THREE.Mesh(sunGeometry, sunMaterial);
		sunCircle.position.z = 500;
		sunCircle.rotation.y = Math.PI;
		scene.add(sunCircle);

		var spotLightMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
		var sphereMesh  = new THREE.SphereGeometry(10, 16, 16);
		var spotLightParent = new THREE.Object3D();
		var pointLights = [
			new THREE.PointLight(0xa30000, 0.5),
			new THREE.PointLight(0x00a300, 0.5),
			new THREE.PointLight(0x0000a3, 0.5)
		];
		var pointLightHelpers = [
			new THREE.Mesh(sphereMesh, spotLightMaterial),
			new THREE.Mesh(sphereMesh, spotLightMaterial),
			new THREE.Mesh(sphereMesh, spotLightMaterial)
		];
		var radius = 300;
		for(var i = 0; i < pointLights.length; i++){
			pointLights[i].position.set(Math.sin(i * (2*Math.PI/3)) * radius, 100, Math.cos(i * (2*Math.PI/3)) * radius);
			pointLightHelpers[i].position.set(Math.sin(i * (2*Math.PI/3)) * radius, 100, Math.cos(i * (2*Math.PI/3)) * radius);
		}
		spotLightParent.add(pointLights[0]);
		spotLightParent.add(pointLights[1]);
		spotLightParent.add(pointLights[2]);
		// spotLightParent.add(pointLightHelpers[0]);
		// spotLightParent.add(pointLightHelpers[1]);
		// spotLightParent.add(pointLightHelpers[2]);
		scene.add(spotLightParent);

		//set up composer
		var bgPass = new THREE.RenderPass(bgScene, bgCamera);
		var renderPass = new THREE.RenderPass(scene, camera);
		renderPass.clear = false;
		var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
		effectCopy.renderToScreen = true;
		var composer = new THREE.EffectComposer(renderer);
		composer.addPass(bgPass);
		composer.addPass(renderPass);
		composer.addPass(effectCopy);

		function renderScene(){
			// pointLight.position.
			// spotLightHelper.update();

			// orbitControls.update(clock.getDelta());
			// spotLightHelper.update();
			spotLightParent.rotation.y += 0.01;

			sunCircle.position.y = spotlightOptions.height;
			spotlight.position.y = spotlightOptions.height *1.8;
			bgMaterial.uniforms.mousePoint.value = spotlightOptions.height + 2.0* window.innerHeight/2;

			spotlight.intensity = spotlightOptions.intensity;
			spotlight.distance = spotlightOptions.distance;
			spotlight.angle = spotlightOptions.angle;

			// renderer.render(scene,camera);
			// renderer.render(bgScene,bgCamera);
			var offset, 
				positions = plane.geometry.vertices;
			for(var i = 0; i < positions.length; i++){
				offset = noise.simplex3(positions[i].x/20 , positions[i].y /20, clock.getElapsedTime()/10) * 15;
				positions[i].z = offset;
			}

			planeGeometry.computeFaceNormals();
			planeGeometry.normalsNeedUpdate = true;
			planeGeometry.verticesNeedUpdate = true;

			//composite rendering
			renderer.autoClear = false;
			composer.render();

			requestAnimationFrame(renderScene);
		}

		document.addEventListener('mousemove', function(e){
			// bgMaterial.uniforms.mousePoint.value = window.innerHeight-e.y;
		});


		renderScene();

	</script>
</body>