<!DOCTYPE html>
<html>
<head>
	<title>Noise Terrain</title>
	<script src="js/third_party/three.min.js"></script>
	<script src="js/third_party/EffectComposer.js"></script>
	<script src="js/third_party/CopyShader.js"></script>
	<script src="js/third_party/ShaderPass.js"></script>
	<script src="js/third_party/MaskPass.js"></script>
	<script src="js/third_party/RenderPass.js"></script>
	<script src="js/third_party/stats.min.js"></script>
	<script src="js/third_party/dat.gui.min.js"></script>
	<script src="js/third_party/OrbitControls.js"></script>
	<script src="js/third_party/perlin.js"></script>
	<link rel="stylesheet" href="css/style.css">
</head>
<body>
	<div id="Stats-output"></div>
	<div id="WebGL-output"></div>
	<script>
		//use perlin noise to mess with a mesh
		var gui = new dat.GUI();
		var spotlightOptions = new function(){
			this.z = 500;
			this.height = 250;
			this.intensity = 1.0;
			this.distance = 0;
			this.angle = Math.PI/3;
			this.exponent = 10.0;
		};
		gui.add(spotlightOptions, 'z', 100, 500);
		gui.add(spotlightOptions, 'height', -200, 500);
		gui.add(spotlightOptions, 'intensity', 0.0, 1.0);
		gui.add(spotlightOptions, 'distance', 0, 1000);
		gui.add(spotlightOptions, 'angle', Math.PI/3, Math.PI/2);

		//background stuff
		var bgScene = new THREE.Scene();
		var bgCamera = new THREE.OrthographicCamera( -window.innerWidth, window.innerWidth, window.innerHeight, -window.innerHeight, 1, 1000 );
		bgCamera.position.z = 100;
		var bgMaterial = new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture('img/stars.png'),
			depthTest: false
		});
		var bgPlane = new THREE.Mesh(
			new THREE.PlaneBufferGeometry(window.innerWidth * 2, window.innerHeight * 2),
			bgMaterial
		);
		bgScene.add(bgPlane);

		//main terrain stuff
		var scene = new THREE.Scene(),
			renderer = new THREE.WebGLRenderer(),
			clock = new THREE.Clock(),
			camera = new THREE.PerspectiveCamera(45, window.innerWidth/ window.innerHeight, 0.1, 1000);
		camera.position.z = -500;
		camera.position.y = 50;
		camera.lookAt(scene.position);
		var orbitControls = new THREE.OrbitControls(camera);

		var offset;
		var color = new THREE.Color();
		var planeGeometry = new THREE.PlaneGeometry(2000, 1000, 100, 50);
		var positions = planeGeometry.vertices;
		for(var i = 0; i < positions.length; i++){
			offset = noise.perlin3(i-2/10, i-1/10, i/10);
			positions[i].z = positions[i].z + offset * 12;
		}
		
		planeGeometry.computeFaceNormals();
		planeGeometry.computeVertexNormals();

		var planePhongMaterial = new THREE.MeshPhongMaterial({ 
			color: 0xD324FF, 
			specular: 0x0000fa, 
			shininess: 100, 
			shading: THREE.FlatShading
		});
		var planeWireframeMaterial = new THREE.MeshPhongMaterial({
			color: 0xffffff,
			specular: 0xfa0000,
			shininess: 100,
			wireframe: true,
			wireframeLinewidth: 3
		});

		var plane = THREE.SceneUtils.createMultiMaterialObject(planeGeometry, [
			planePhongMaterial,
			planeWireframeMaterial
		]);

		plane.rotation.x = -Math.PI/2;

		scene.add(plane);

		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMapEnabled = true;

		var outputElement = document.getElementById('WebGL-output');
		outputElement.appendChild(renderer.domElement);

		var spotLightColor = 0xFFF9B3;
		var spotlight = new THREE.SpotLight(spotLightColor);
		spotlight.position.set(0, 100, -200);
		spotlight.castShadow = true;
		scene.add(spotlight);

		var sunMaterial = new THREE.MeshBasicMaterial({
			color: spotLightColor
		});
		var sunGeometry= new THREE.CircleGeometry(100, 32);
		var sunCircle = new THREE.Mesh(sunGeometry, sunMaterial);
		sunCircle.rotation.y = Math.PI;
		scene.add(sunCircle);

		var testMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
		var sphereMesh  = new THREE.SphereGeometry(10, 16, 16);
		var spotLightParent = new THREE.Object3D();
		var pointLights = [
			new THREE.PointLight(0xa30000, 0.5),
			new THREE.PointLight(0x00a300, 0.5),
			new THREE.PointLight(0x0000a3, 0.5)
		];
		var pointLightHelpers = [
			new THREE.Mesh(sphereMesh, testMaterial),
			new THREE.Mesh(sphereMesh, testMaterial),
			new THREE.Mesh(sphereMesh, testMaterial)
		];
		var radius = 300;
		for(var i = 0; i < pointLights.length; i++){
			pointLights[i].position.set(Math.sin(i * (2*Math.PI/3)) * radius, 100, Math.cos(i * (2*Math.PI/3)) * radius);
			pointLightHelpers[i].position.set(Math.sin(i * (2*Math.PI/3)) * radius, 100, Math.cos(i * (2*Math.PI/3)) * radius);
		}
		spotLightParent.add(pointLights[0]);
		spotLightParent.add(pointLights[1]);
		spotLightParent.add(pointLights[2]);
		// spotLightParent.add(pointLightHelpers[0]);
		// spotLightParent.add(pointLightHelpers[1]);
		// spotLightParent.add(pointLightHelpers[2]);
		scene.add(spotLightParent);

		//set up composer
		var bgPass = new THREE.RenderPass(bgScene, bgCamera);
		var renderPass = new THREE.RenderPass(scene, camera);
		renderPass.clear = false;
		var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
		effectCopy.renderToScreen = true;
		var composer = new THREE.EffectComposer(renderer);
		composer.addPass(bgPass);
		composer.addPass(renderPass);
		composer.addPass(effectCopy);

		function renderScene(){
			// pointLight.position.
			// spotLightHelper.update();

			orbitControls.update(clock.getDelta());
			// spotLightHelper.update();
			spotLightParent.rotation.y += 0.01;

			sunCircle.position.y = spotlight.position.y = spotlightOptions.height;
			sunCircle.position.z = spotlight.position.z = spotlightOptions.z;

			spotlight.intensity = spotlightOptions.intensity;
			spotlight.distance = spotlightOptions.distance;
			spotlight.angle = spotlightOptions.angle;
			spotlight.exponent = spotlightOptions.exponent;
			spotlight.shadowCameraNear = spotlightOptions.shadowCameraNear;
			spotlight.shadowCameraFar = spotlightOptions.shadowCameraFar;
			spotlight.shadowCameraFov = spotlightOptions.shadowCameraFov;

			// renderer.render(scene,camera);
			// renderer.render(bgScene,bgCamera);

			//composite rendering
			renderer.autoClear = false;
			composer.render();

			requestAnimationFrame(renderScene);
		}

		renderScene();

	</script>
</body>