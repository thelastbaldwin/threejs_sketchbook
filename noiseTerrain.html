<!DOCTYPE html>
<html>
<head>
	<title>Noise Terrain</title>
	<script src="js/third_party/three.min.js"></script>
	<script src="js/third_party/stats.min.js"></script>
	<script src="js/third_party/dat.gui.min.js"></script>
	<script src="js/third_party/OrbitControls.js"></script>
	<script src="js/third_party/perlin.js"></script>
	<link rel="stylesheet" href="css/style.css">
</head>
<body>
	<div id="Stats-output"></div>
	<div id="WebGL-output"></div>
	<script>
		//use perlin noise to mess with a mesh
		var gui = new dat.GUI();
		var spotlightOptions = new function(){
			this.z = 500;
			this.height = 250;
			this.intensity = 1.0;
			this.distance = 0;
			this.angle = Math.PI/3;
			this.exponent = 10.0;
		};
		gui.add(spotlightOptions, 'z', 100, 500);
		gui.add(spotlightOptions, 'height', -200, 500);
		gui.add(spotlightOptions, 'intensity', 0.0, 1.0);
		gui.add(spotlightOptions, 'distance', 0, 1000);
		gui.add(spotlightOptions, 'angle', Math.PI/3, Math.PI/2);

		var scene = new THREE.Scene(),
			renderer = new THREE.WebGLRenderer(),
			// testAxes = new THREE.AxisHelper(100),
			clock = new THREE.Clock(),
			camera = new THREE.PerspectiveCamera(45, window.innerWidth/ window.innerHeight, 0.1, 1000);
		camera.position.z = -500;
		camera.position.y = 50;
		camera.lookAt(scene.position);

		// var orbitControls = new THREE.OrbitControls(camera);

		var offset;
		var color = new THREE.Color();
		// PlaneGeometry(width, height, widthSegments, heightSegments)
		// can't use buffer geometry without giving up thicker lines
		// var planeGeometry = new THREE.PlaneBufferGeometry(2000, 1000, 200, 100);
		// var positions = planeGeometry.attributes.position.array;
		// for(var i = 2; i < positions.length; i+=3){
		// 	offset = noise.perlin3(i-2/10, i-1/10, i/10);
		// 	positions[i] += offset * 12;
		// }
		var planeGeometry = new THREE.PlaneGeometry(2000, 1000, 100, 50);
		var positions = planeGeometry.vertices;
		for(var i = 0; i < positions.length; i++){
			offset = noise.perlin3(i-2/10, i-1/10, i/10);
			positions[i].z = positions[i].z + offset * 12;
		}
		
		planeGeometry.computeFaceNormals();
		planeGeometry.computeVertexNormals();

		var planePhongMaterial = new THREE.MeshPhongMaterial({ 
			color: 0xD324FF, 
			specular: 0x0000fa, 
			shininess: 100, 
			shading: THREE.FlatShading
		});
		var planeWireframeMaterial = new THREE.MeshPhongMaterial({
			color: 0xffffff,
			specular: 0xfa0000,
			shininess: 100,
			wireframe: true,
			wireframeLinewidth: 3
		});

		var plane = THREE.SceneUtils.createMultiMaterialObject(planeGeometry, [	
			planePhongMaterial,
			planeWireframeMaterial
		]);

		plane.rotation.x = -Math.PI/2;

		scene.add(plane);

		renderer.setClearColor(0xcccccc);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMapEnabled = true;

		var outputElement = document.getElementById('WebGL-output');
		outputElement.appendChild(renderer.domElement);

		var spotLightColor = 0xFFF9B3;
		var spotlight = new THREE.SpotLight(spotLightColor);
		spotlight.position.set(0, 100, -200);
		spotlight.castShadow = true;
		scene.add(spotlight);

		var sunMaterial = new THREE.MeshBasicMaterial({
			color: spotLightColor
		});
		var sunGeometry= new THREE.CircleGeometry(100, 32);
		var sunCircle = new THREE.Mesh(sunGeometry, sunMaterial);
		sunCircle.rotation.y = Math.PI;
		scene.add(sunCircle);

		// var spotLightHelper = new THREE.SpotLightHelper(spotlight, 10);
		// this.scene.add(spotLightHelper);

		var testMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
		var sphereMesh  = new THREE.SphereGeometry(10, 16, 16);
		var spotLightParent = new THREE.Object3D();
		var pointLights = [
			new THREE.PointLight(0xa30000, 0.5),
			new THREE.PointLight(0x00a300, 0.5),
			new THREE.PointLight(0x0000a3, 0.5)
		];
		var pointLightHelpers = [
			new THREE.Mesh(sphereMesh, testMaterial),
			new THREE.Mesh(sphereMesh, testMaterial),
			new THREE.Mesh(sphereMesh, testMaterial)
		];
		var radius = 300;
		for(var i = 0; i < pointLights.length; i++){
			pointLights[i].position.set(Math.sin(i * (2*Math.PI/3)) * radius, 100, Math.cos(i * (2*Math.PI/3)) * radius);
			pointLightHelpers[i].position.set(Math.sin(i * (2*Math.PI/3)) * radius, 100, Math.cos(i * (2*Math.PI/3)) * radius);
		}
		spotLightParent.add(pointLights[0]);
		spotLightParent.add(pointLights[1]);
		spotLightParent.add(pointLights[2]);
		spotLightParent.add(pointLightHelpers[0]);
		spotLightParent.add(pointLightHelpers[1]);
		spotLightParent.add(pointLightHelpers[2]);
		scene.add(spotLightParent);

		function renderScene(){
			// pointLight.position.
			// spotLightHelper.update();

			// orbitControls.update(clock.getDelta());
			// spotLightHelper.update();
			spotLightParent.rotation.y += 0.01;

			sunCircle.position.y = spotlight.position.y = spotlightOptions.height;
			sunCircle.position.z = spotlight.position.z = spotlightOptions.z;

			spotlight.intensity = spotlightOptions.intensity;
			spotlight.distance = spotlightOptions.distance;
			spotlight.angle = spotlightOptions.angle;
			spotlight.exponent = spotlightOptions.exponent;
			spotlight.shadowCameraNear = spotlightOptions.shadowCameraNear;
			spotlight.shadowCameraFar = spotlightOptions.shadowCameraFar;
			spotlight.shadowCameraFov = spotlightOptions.shadowCameraFov;

			requestAnimationFrame(renderScene);
			renderer.render(scene,camera);
		}

		renderScene();

	</script>
</body>